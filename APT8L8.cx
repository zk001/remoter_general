/***********************************************************
*  Company:  APT Chip
*  Author :
*  Version:
*  Other  :
*  Demo   :#define   APT_SDA_HIGH     P1.0
*********************************************************/
//#include "../../proj/tl_common.h"
//#include "key_def.h"
//#include "../mcu/clock.h"
//#include "gpio_8368.h"
#include "led.h"
//#include "apt8l08_key_sim.h"
#include "apt8l08_key.h"

#include "main.h"
#include "../drivers.h"
#include "mechanical_key.h"
#if defined(APT8L08_KEY)
//#define   APT_SDA_INPUT    XXX
//#define   APT_SDA_OUTPUT   XXX
//#define   APT_SDA_HIGH     XXX
//#define   APT_SDA_LOW      XXX
//#define   APT_SCL_HIGH     XXX
//#define   APT_SCL_LOW      XXX
//#define   READ_SDA_STATUS  XXX

//#define		APT_PIN_I2C_SCL			GPIO_GP2			//SCL
//#define		APT_PIN_I2C_SDA			GPIO_GP4			//SDA
//#define		APT_PIN_I2C_SCL			GPIO_GP20			//SCL
//#define		APT_PIN_I2C_SDA			GPIO_GP21			//SDA
//#define APT8_SDA GPIO_PB6
//#define APT8_SCL GPIO_PD7

//#define		APT_PIN_I2C_SCL			GPIO_GP6			//SCL
//#define		APT_PIN_I2C_SDA			GPIO_GP4			//SDA
#define		IIC_SPEED			100

#define		APT_PIN_I2C_SCL			GPIO_PD7			//SCL
#define		APT_PIN_I2C_SDA			GPIO_PB6			//SDA

#define   PartAdd          0xac     //[]
//static u8 APTRdFourArry[4];
//一般默认参考配置，全局灵敏度02，速率500K,按键阈值不小于04。灵敏度和扫描速率需要同步调整
//1：按键阀值由04改为02，全局灵敏度保持02，速率500K，但是有误触发风险，批量阀值不能小于04
//1：按键阀值保持默认04，全局灵敏度提高为04，速率500K，反应太慢-功耗36ua
//1：按键阀值保持默认04，全局灵敏度提高为04，速率1M，反应很好-功耗56ua
//楼空PCB改变，全局灵敏度由04变为02(降低灵敏度抗干扰，提高灵敏度速率必须1M)，速率04变05同步由1M改为500K(降低功耗)----这两者互为关联
//const u8 APTT8L16ArrySensing[16]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};
/*********************************************喷嘴-  喷嘴+ 水压+ 水压- 水温	座温	 风温 */
/****************************************SW0  SW1	SW2  SW3  SW4  SW5  SW6  SW7*/
//以下为产品阀值---按键长期按失效
static const u8 APTT8L16ArrySensing[8]= {0xff,0x05,0x04,0x04,0x06,0x06,0x06,0x07};
//以下为产品阀值---提高灵敏度
//static const u8 APTT8L16ArrySensing[8]= {0xff,0x05,0x03,0x03,0x07,0x04,0x06,0x08};

/*
static const u8 APTT8L16ArrySensing[8]= {0xff,0x04,0x04,0x04,0x05,0x05,0x05,0x05};
static const u8 APTT8L16ArrySensing[8]= {0xff,0x04,0x03,0x03,0x04,0x04,0x04,0x04};
*/
//以下为产品阀值---按键长期按失效
static const u8 	  APTTouchRegDat[14]={0x02,0x53,0x20,0x01,0x00,0x00,0x08,0x02,0x02,0x10,0x10,0x04,0x00,0x00};
//以下为产品阀值---提高灵敏度，扫描速率
//static const u8 	  APTTouchRegDat[14]={0x04,0x50,0x20,0x01,0x00,0x00,0x08,0x02,0x02,0x10,0x10,0x04,0x00,0x00};

static const u8 	  APTTouchRegAdd[14]={0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d};
//全局灵敏度02默认值，调整到04太灵敏了，速度500K针对02的灵敏度没问题，只有一个按键阀值02.
//以下是测试模式，速度由500K调整为1M，开发模式打开(0x2d,0x2a修改)
//static const u8 test_APTT8L16ArrySensing[16]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};

//const u8 test_APTTouchRegDat[14]={0x04,0x00,0x20,0x00,0x00,0x00,0x08,0x02,0x02,0x10,0xff,0x04,0x00,0x08};
//const u8 test_APTTouchRegAdd[14]={0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d};
//0x20 全局灵敏度寄存器GSR默认02,值越高越灵敏，但是按键响应越慢
//0X21控制寄存器MCOM,默认值0x01,速率500K，单键模式，  0x00为1M模式，0X00-0XFF按键阀值寄存器KOR
//#define SDA_LOW(SDA)   st(gpio_write(SDA, 0);)
//#define SDA_HIGH(SDA)  st(gpio_write(SDA, 1);)
//#define SCL_HIGH(SCL)  st(gpio_write(SCL, 1);)
//#define SCL_LOW(SCL)   st(gpio_write(SCL, 0);)
static inline void ATP_i2c_sim_scl_out(int v){
	gpio_set_output_en(APT_PIN_I2C_SCL,(!v));
//	gpio_write(APT_PIN_I2C_SCL, v);
}
static inline void ATP_i2c_sim_sda_out(int v){
	gpio_set_output_en(APT_PIN_I2C_SDA,(!v));
//	gpio_write(APT_PIN_I2C_SDA, v);

}
static inline int ATP_i2c_sim_sda_in(void){
	return gpio_read(APT_PIN_I2C_SDA);
}
static inline void ATP_i2c_sim_sda_pin_input(void){
	gpio_set_func(APT_PIN_I2C_SDA, AS_GPIO);
	gpio_set_output_en(APT_PIN_I2C_SDA, 0);
	gpio_set_input_en(APT_PIN_I2C_SDA, 1);
}
static inline void ATP_i2c_sim_sda_pin_output(void){
	gpio_set_func(APT_PIN_I2C_SDA, AS_GPIO);
	gpio_set_output_en(APT_PIN_I2C_SDA, 1);
	gpio_set_input_en(APT_PIN_I2C_SDA, 0);
}
static void Delay(u16 nCount)
{
 //for(; nCount != 0; nCount--);
//	CLOCK_DLY_600NS;
//	CLOCK_DLY_600NS;
//	CLOCK_DLY_600NS;
	WaitUs(5);
}
static void  APTTouchStart(void)
{
 ATP_i2c_sim_sda_out(1);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(1);
 Delay(IIC_SPEED);
 ATP_i2c_sim_sda_out(0);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(0);
 Delay(IIC_SPEED);
 Delay(IIC_SPEED);
}
static void  APTTouchStop(void)
{
	ATP_i2c_sim_sda_out(0);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(1);
 Delay(IIC_SPEED);
 ATP_i2c_sim_sda_out(1);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(1);
 Delay(IIC_SPEED);
 Delay(IIC_SPEED);
}
static void  APTTouchWaitAck(void)
{
 unsigned char WaitTimeCnt;
 ATP_i2c_sim_sda_pin_input();
 ATP_i2c_sim_scl_out(1);
 WaitTimeCnt=10;
do{
   Delay(IIC_SPEED);
   Delay(IIC_SPEED);
   WaitTimeCnt--;
   }while((ATP_i2c_sim_sda_in())&&WaitTimeCnt);
ATP_i2c_sim_scl_out(0);
ATP_i2c_sim_sda_pin_output();
}

static void  APTTouchACK(void)
{
 ATP_i2c_sim_sda_out(0);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(1);
 Delay(IIC_SPEED);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(0);
 Delay(IIC_SPEED);
 Delay(IIC_SPEED);
}
static void  APTTouchNoACK(void)
{
	ATP_i2c_sim_sda_out(1);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(1);
 Delay(IIC_SPEED);
 Delay(IIC_SPEED);
 ATP_i2c_sim_scl_out(0);
 Delay(IIC_SPEED);
 Delay(IIC_SPEED);
}
static void  APTTouchWriteData(unsigned char WrData)
{
 unsigned char  WrDataCnt;
 for(WrDataCnt=0;WrDataCnt<8;WrDataCnt++)
    {
     if(WrData&0x80)
    	 ATP_i2c_sim_sda_out(1);
     else
    	 ATP_i2c_sim_sda_out(0);
     Delay(IIC_SPEED);
     ATP_i2c_sim_scl_out(1);
     Delay(IIC_SPEED);
     Delay(IIC_SPEED);
     ATP_i2c_sim_scl_out(0);
     Delay(IIC_SPEED);
     WrData=WrData<<1;
    }
}

static unsigned char  APTTouchReadData(void)
{
 unsigned char  RdDataCnt,RdData;
 ATP_i2c_sim_sda_pin_input();
 RdData=0x00;
 for(RdDataCnt=0;RdDataCnt<8;RdDataCnt++)
   {
    RdData=RdData<<1;
    ATP_i2c_sim_scl_out(1);
    Delay(IIC_SPEED);

    if(ATP_i2c_sim_sda_in())
    RdData=RdData|0x01;
    Delay(IIC_SPEED);
    ATP_i2c_sim_scl_out(0);
    Delay(IIC_SPEED);
   }
 ATP_i2c_sim_sda_pin_output();
 return(RdData);
}
static void  APTTouchWrOneData(unsigned char APTWrAdd,unsigned char APTWrData)
{
 APTTouchStart();
 APTTouchWriteData(0xac);
 APTTouchWaitAck();
 APTTouchWriteData(APTWrAdd);
 APTTouchWaitAck();
 APTTouchWriteData(APTWrData);
 APTTouchWaitAck();
 APTTouchStop();
}

unsigned char  APT8L8TouchRdOneData(unsigned char APTRdAdd)
{
 unsigned char APTRdData,APTBuffer;
 APTRdData=0;
 APTTouchStart();
 APTTouchWriteData(0xac);
 APTTouchWaitAck();
 APTTouchWriteData(APTRdAdd);
 APTTouchWaitAck();
 APTTouchStart();
 APTBuffer=0xac|0x01;
 APTTouchWriteData(APTBuffer);
 APTTouchWaitAck();
 APTRdData=APTTouchReadData();
 APTTouchNoACK();
 APTTouchStop();
 return APTRdData;
}
extern u8 ss;
static void  APTTouchChipSetInOut(unsigned char ChipSetInOut)
{
 u8  ChipSetValueA,ChipSetValueB,TimeCnt;
 if(ChipSetInOut==1)
	 ChipSetValueA=0x5a;
 else
	 ChipSetValueA=0x00;

 TimeCnt=10;

 do{
   APTTouchWrOneData(0x3a,ChipSetValueA);

   WaitUs(5);
   ChipSetValueB=APT8L8TouchRdOneData(0x3a);
   if(ChipSetValueB!=ChipSetValueA)
   {
	 WaitMs(20);
    TimeCnt--;
   }
 }while((ChipSetValueB!=ChipSetValueA)&&(TimeCnt!=0));
// if(ChipSetValueB == ChipSetValueA)
//	 ss = 1;
	// HalLedSet (HAL_LED_ALL, HAL_LED_MODE_ON);
}

static void  APTTouchChipRegSet(unsigned char ChipRegAdd,unsigned char ChipRegValueA)
{
 unsigned char  ChipRegValueB,TimeCnt;
 TimeCnt=10;
 do{
   APTTouchWrOneData(ChipRegAdd,ChipRegValueA);
   WaitUs(5);
   ChipRegValueB=APT8L8TouchRdOneData(ChipRegAdd);
   if(ChipRegValueB!=ChipRegValueA)
    {
     WaitMs(10);
     TimeCnt--;
    }
   }while((ChipRegValueB!=ChipRegValueA)&&(TimeCnt!=0));
}
/*
static void  APTTouchRdFourData(unsigned char APTRdAdd)
{
 unsigned char APTBuffer;
 APTTouchStart();
 APTTouchWriteData(0xac);
 APTTouchWaitAck();
 APTTouchWriteData(APTRdAdd);
 APTTouchWaitAck();
 APTTouchStart();
 APTBuffer=0xac|0x01;
 APTTouchWriteData(APTBuffer);
 APTTouchWaitAck();
 APTRdFourArry[1]=APTTouchReadData();
 APTTouchACK();
 APTRdFourArry[0]=APTTouchReadData();
 APTTouchACK();
 APTRdFourArry[3]=APTTouchReadData();
 APTTouchACK();
 APTRdFourArry[2]=APTTouchReadData();
 APTTouchNoACK();
 APTTouchStop();
}

static unsigned char APTTouchWrReg(unsigned char APTRegAdd,unsigned char APTRegData)
{
 unsigned char APTRdData;
 if(APTRegAdd==0x3a)
 {
  APTTouchWrOneData(APTRegAdd,APTRegData);
  return (APTRegData);
 }
 APTTouchChipSetInOut(1);
 APTTouchWrOneData(APTRegAdd,APTRegData);
 APTTouchChipSetInOut(0);
 APTRdData=APT8L8TouchRdOneData(APTRegAdd);
 return APTRdData;
}*/
/*
static void  ScanAPTTouchKey(void)
{
 unsigned char  APTTouchKeyValueA,APTTouchKeyValueB;
 u32       APTTouchKeyValueC;
 APTTouchKeyValueA=APTTouchRdOneData(0x34);
 APTTouchKeyValueB=APTTouchRdOneData(0x35);
 APTTouchKeyValueC=APTTouchKeyValueB*256+APTTouchKeyValueA;
 switch(APTTouchKeyValueC)
 {
   case 0x0001:break;
   case 0x0002:break;
   case 0x0004:break;
   case 0x0008:break;
   case 0x0010:break;
   case 0x0020:break;
   case 0x0040:break;
   case 0x0080:break;
   case 0x0100:break;
   case 0x0200:break;
   case 0x0400:break;
   case 0x0800:break;
   case 0x1000:break;
   case 0x2000:break;
   case 0x4000:break;
   case 0x8000:break;
   default:break;
 }
}*/
/*
static void ATP_Init_Interval_Scan_Mode(void)
{
	//APTTouchChipSetInOut(2);//不停止系统，但是可以设置寄存器
	APTTouchWrOneData(0x3a,0x5a);
	APTTouchWrOneData(0x2d,0x00);
	APTTouchWrOneData(0x2d,0x70);
}

static void ATP_Interval_Scan_Mode(void)
{
	//APTTouchChipSetInOut(2);//不停止系统，但是可以设置寄存器
	APTTouchWrOneData(0x3a,0x53);
	APTTouchWrOneData(0x2d,0x00);
	APTTouchWrOneData(0x2d,0x70);
}
void ATP8L16_STOP(void)
{
	APTTouchChipSetInOut(1);
}*/
void APT8L8Reset(void)
{
 APTTouchChipSetInOut(1);
 WaitMs(5);
 APTTouchChipSetInOut(0);
 WaitMs(5);
}
void APT8L8Init(void)
{
	u8 data;
 u8 i,APTRdDataBuffer;
 APTTouchChipSetInOut(1);
 WaitMs(5);
 APTTouchChipSetInOut(0);
 WaitMs(5);

 APTTouchChipSetInOut(1);

// data = APT8L8TouchRdOneData(0x20);
// if(data == 0x02)
//	 HalLedSet (HAL_LED_ALL, HAL_LED_MODE_ON);
 for(i=0;i<14;)
  {
   APTTouchWrOneData(APTTouchRegAdd[i],APTTouchRegDat[i]);
   WaitMs(1);
   APTRdDataBuffer=APT8L8TouchRdOneData(APTTouchRegAdd[i]);
   if(APTRdDataBuffer==APTTouchRegDat[i])
   i++;
   WaitMs(1);
  }
 //APTTouchWrOneData(0x2d,0x70);//间隔扫描模式
  for(i=0;i<8;i++)
  {
   APTTouchChipRegSet(i,APTT8L16ArrySensing[i]);
  }


 APTTouchChipSetInOut(0);
 WaitMs(300);
}
/*
void test_APT8L16Init(void)
{
 u8 i,APTRdDataBuffer;
 APTTouchChipSetInOut(1);
 WaitMs(5);
 APTTouchChipSetInOut(0);
 WaitMs(5);

 APTTouchChipSetInOut(1);

 for(i=0;i<14;)
  {
   APTTouchWrOneData(test_APTTouchRegAdd[i],test_APTTouchRegDat[i]);
   WaitMs(1);
   APTRdDataBuffer=APTTouchRdOneData(test_APTTouchRegAdd[i]);
   if(APTRdDataBuffer==test_APTTouchRegDat[i])
   i++;
   WaitMs(1);
  }
  for(i=0;i<16;i++)
  {
   APTTouchChipRegSet(i,test_APTT8L16ArrySensing[i]);
  }

 APTTouchChipSetInOut(0);
 WaitMs(300);
}*/
/*
void main(void)
{
 APT8L16Init();
 while(1){
  DelayMs(10);
  ScanAPTTouchKey();
 }
}*/
#endif
